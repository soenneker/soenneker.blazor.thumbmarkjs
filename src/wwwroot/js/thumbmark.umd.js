!function (e, n) { "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((e = "undefined" != typeof globalThis ? globalThis : e || self).ThumbmarkJS = {}) }(this, (function (e) { "use strict"; const n = { exclude: [], include: [], logging: !0, timeout: 5e3, cache_api_call: !0, performance: !1 }; let t = { ...n }; function r() { var e, n, t, r, o, i; if ("undefined" == typeof navigator) return { name: "unknown", version: "unknown" }; const a = navigator.userAgent, s = [/(?<name>SamsungBrowser)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>EdgA|EdgiOS|Edg)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>OPR|OPX)\/(?<version>\d+(?:\.\d+)+)/, /Opera[\s\/](?<version>\d+(?:\.\d+)+)/, /Opera Mini\/(?<version>\d+(?:\.\d+)+)/, /Opera Mobi\/(?<version>\d+(?:\.\d+)+)/, /(?<name>Vivaldi)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>Brave)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>CriOS)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>FxiOS)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>Chrome|Chromium)\/(?<version>\d+(?:\.\d+)+)/, /(?<name>Firefox|Waterfox|Iceweasel|IceCat)\/(?<version>\d+(?:\.\d+)+)/, /Version\/(?<version1>[\d.]+).*Safari\/[\d.]+|(?<name>Safari)\/(?<version2>[\d.]+)/, /(?<name>MSIE|Trident|IEMobile).+?(?<version>\d+(?:\.\d+)+)/, /(?<name>[A-Za-z]+)\/(?<version>\d+(?:\.\d+)+)/], c = { edg: "Edge", edga: "Edge", edgios: "Edge", opr: "Opera", opx: "Opera", crios: "Chrome", fxios: "Firefox", samsung: "SamsungBrowser", vivaldi: "Vivaldi", brave: "Brave" }; for (const u of s) { const s = a.match(u); if (s) { let a = null === (e = s.groups) || void 0 === e ? void 0 : e.name, l = (null === (n = s.groups) || void 0 === n ? void 0 : n.version) || (null === (t = s.groups) || void 0 === t ? void 0 : t.version1) || (null === (r = s.groups) || void 0 === r ? void 0 : r.version2); if (a || !(null === (o = s.groups) || void 0 === o ? void 0 : o.version1) && !(null === (i = s.groups) || void 0 === i ? void 0 : i.version2) || (a = "Safari"), !a && u.source.includes("Opera Mini") && (a = "Opera Mini"), !a && u.source.includes("Opera Mobi") && (a = "Opera Mobi"), !a && u.source.includes("Opera") && (a = "Opera"), !a && s[1] && (a = s[1]), !l && s[2] && (l = s[2]), a) { return { name: c[a.toLowerCase()] || a, version: l || "unknown" } } } } return { name: "unknown", version: "unknown" } } function o() { if ("undefined" == typeof navigator || !navigator.userAgent) return !1; const e = navigator.userAgent; return /Mobi|Android|iPhone|iPod|IEMobile|Opera Mini|Opera Mobi|webOS|BlackBerry|Windows Phone/i.test(e) && !/iPad/i.test(e) } function i(e) { let n = 0; for (let t = 0; t < e.length; ++t)n += Math.abs(e[t]); return n } function a(e, n, t) { let r = []; for (let n = 0; n < e[0].data.length; n++) { let t = []; for (let r = 0; r < e.length; r++)t.push(e[r].data[n]); r.push(s(t)) } const o = new Uint8ClampedArray(r); return new ImageData(o, n, t) } function s(e) { if (0 === e.length) return 0; const n = {}; for (const t of e) n[t] = (n[t] || 0) + 1; let t = e[0]; for (const e in n) n[e] > n[t] && (t = parseInt(e, 10)); return t } function c(e) { return e ^= e >>> 16, e = Math.imul(e, 2246822507), e ^= e >>> 13, e = Math.imul(e, 3266489909), (e ^= e >>> 16) >>> 0 } const u = new Uint32Array([597399067, 2869860233, 951274213, 2716044179]); function l(e, n) { return e << n | e >>> 32 - n } function d(e, n = 0) { var t; if (n = n ? 0 | n : 0, "string" == typeof e && (t = e, e = (new TextEncoder).encode(t).buffer), !(e instanceof ArrayBuffer)) throw new TypeError("Expected key to be ArrayBuffer or string"); const r = new Uint32Array([n, n, n, n]); !function (e, n) { const t = e.byteLength / 16 | 0, r = new Uint32Array(e, 0, 4 * t); for (let e = 0; e < t; e++) { const t = r.subarray(4 * e, 4 * (e + 1)); t[0] = Math.imul(t[0], u[0]), t[0] = l(t[0], 15), t[0] = Math.imul(t[0], u[1]), n[0] = n[0] ^ t[0], n[0] = l(n[0], 19), n[0] = n[0] + n[1], n[0] = Math.imul(n[0], 5) + 1444728091, t[1] = Math.imul(t[1], u[1]), t[1] = l(t[1], 16), t[1] = Math.imul(t[1], u[2]), n[1] = n[1] ^ t[1], n[1] = l(n[1], 17), n[1] = n[1] + n[2], n[1] = Math.imul(n[1], 5) + 197830471, t[2] = Math.imul(t[2], u[2]), t[2] = l(t[2], 17), t[2] = Math.imul(t[2], u[3]), n[2] = n[2] ^ t[2], n[2] = l(n[2], 15), n[2] = n[2] + n[3], n[2] = Math.imul(n[2], 5) + 2530024501, t[3] = Math.imul(t[3], u[3]), t[3] = l(t[3], 18), t[3] = Math.imul(t[3], u[0]), n[3] = n[3] ^ t[3], n[3] = l(n[3], 13), n[3] = n[3] + n[0], n[3] = Math.imul(n[3], 5) + 850148119 } }(e, r), function (e, n) { const t = e.byteLength / 16 | 0, r = e.byteLength % 16, o = new Uint32Array(4), i = new Uint8Array(e, 16 * t, r); switch (r) { case 15: o[3] = o[3] ^ i[14] << 16; case 14: o[3] = o[3] ^ i[13] << 8; case 13: o[3] = o[3] ^ i[12], o[3] = Math.imul(o[3], u[3]), o[3] = l(o[3], 18), o[3] = Math.imul(o[3], u[0]), n[3] = n[3] ^ o[3]; case 12: o[2] = o[2] ^ i[11] << 24; case 11: o[2] = o[2] ^ i[10] << 16; case 10: o[2] = o[2] ^ i[9] << 8; case 9: o[2] = o[2] ^ i[8], o[2] = Math.imul(o[2], u[2]), o[2] = l(o[2], 17), o[2] = Math.imul(o[2], u[3]), n[2] = n[2] ^ o[2]; case 8: o[1] = o[1] ^ i[7] << 24; case 7: o[1] = o[1] ^ i[6] << 16; case 6: o[1] = o[1] ^ i[5] << 8; case 5: o[1] = o[1] ^ i[4], o[1] = Math.imul(o[1], u[1]), o[1] = l(o[1], 16), o[1] = Math.imul(o[1], u[2]), n[1] = n[1] ^ o[1]; case 4: o[0] = o[0] ^ i[3] << 24; case 3: o[0] = o[0] ^ i[2] << 16; case 2: o[0] = o[0] ^ i[1] << 8; case 1: o[0] = o[0] ^ i[0], o[0] = Math.imul(o[0], u[0]), o[0] = l(o[0], 15), o[0] = Math.imul(o[0], u[1]), n[0] = n[0] ^ o[0] } }(e, r), function (e, n) { n[0] = n[0] ^ e.byteLength, n[1] = n[1] ^ e.byteLength, n[2] = n[2] ^ e.byteLength, n[3] = n[3] ^ e.byteLength, n[0] = n[0] + n[1] | 0, n[0] = n[0] + n[2] | 0, n[0] = n[0] + n[3] | 0, n[1] = n[1] + n[0] | 0, n[2] = n[2] + n[0] | 0, n[3] = n[3] + n[0] | 0, n[0] = c(n[0]), n[1] = c(n[1]), n[2] = c(n[2]), n[3] = c(n[3]), n[0] = n[0] + n[1] | 0, n[0] = n[0] + n[2] | 0, n[0] = n[0] + n[3] | 0, n[1] = n[1] + n[0] | 0, n[2] = n[2] + n[0] | 0, n[3] = n[3] + n[0] | 0 }(e, r); const o = new Uint8Array(r.buffer); return Array.from(o).map((e => e.toString(16).padStart(2, "0"))).join("") } const m = 280; function h(e, n) { return new Promise((t => setTimeout(t, e, n))) } const f = ["Arial", "Arial Black", "Arial Narrow", "Arial Rounded MT", "Arimo", "Archivo", "Barlow", "Bebas Neue", "Bitter", "Bookman", "Calibri", "Cabin", "Candara", "Century", "Century Gothic", "Comic Sans MS", "Constantia", "Courier", "Courier New", "Crimson Text", "DM Mono", "DM Sans", "DM Serif Display", "DM Serif Text", "Dosis", "Droid Sans", "Exo", "Fira Code", "Fira Sans", "Franklin Gothic Medium", "Garamond", "Geneva", "Georgia", "Gill Sans", "Helvetica", "Impact", "Inconsolata", "Indie Flower", "Inter", "Josefin Sans", "Karla", "Lato", "Lexend", "Lucida Bright", "Lucida Console", "Lucida Sans Unicode", "Manrope", "Merriweather", "Merriweather Sans", "Montserrat", "Myriad", "Noto Sans", "Nunito", "Nunito Sans", "Open Sans", "Optima", "Orbitron", "Oswald", "Pacifico", "Palatino", "Perpetua", "PT Sans", "PT Serif", "Poppins", "Prompt", "Public Sans", "Quicksand", "Rajdhani", "Recursive", "Roboto", "Roboto Condensed", "Rockwell", "Rubik", "Segoe Print", "Segoe Script", "Segoe UI", "Sora", "Source Sans Pro", "Space Mono", "Tahoma", "Taviraj", "Times", "Times New Roman", "Titillium Web", "Trebuchet MS", "Ubuntu", "Varela Round", "Verdana", "Work Sans"], g = ["monospace", "sans-serif", "serif"]; function p(e, n) { if (!e) throw new Error("Canvas context not supported"); return e.font, e.font = `72px ${n}`, e.measureText("WwMmLli0Oo").width } function v() { var e; const n = document.createElement("canvas"), t = null !== (e = n.getContext("webgl")) && void 0 !== e ? e : n.getContext("experimental-webgl"); if (t && "getParameter" in t) try { const e = (t.getParameter(t.VENDOR) || "").toString(), n = (t.getParameter(t.RENDERER) || "").toString(); let r = { vendor: e, renderer: n, version: (t.getParameter(t.VERSION) || "").toString(), shadingLanguageVersion: (t.getParameter(t.SHADING_LANGUAGE_VERSION) || "").toString() }; if (!n.length || !e.length) { const e = t.getExtension("WEBGL_debug_renderer_info"); if (e) { const n = (t.getParameter(e.UNMASKED_VENDOR_WEBGL) || "").toString(), o = (t.getParameter(e.UNMASKED_RENDERER_WEBGL) || "").toString(); n && (r.vendorUnmasked = n), o && (r.rendererUnmasked = o) } } return r } catch (e) { } return "undefined" } function w() { const e = new Float32Array(1), n = new Uint8Array(e.buffer); return e[0] = 1 / 0, e[0] = e[0] - e[0], n[3] } const y = (e, n, t, r) => { const o = (t - n) / r; let i = 0; for (let t = 0; t < r; t++) { i += e(n + (t + .5) * o) } return i * o }; function S(e, n) { const t = {}; return n.forEach((n => { const r = function (e) { if (0 === e.length) return null; const n = {}; e.forEach((e => { const t = String(e); n[t] = (n[t] || 0) + 1 })); let t = e[0], r = 1; return Object.keys(n).forEach((e => { n[e] > r && (t = e, r = n[e]) })), t }(e.map((e => n in e ? e[n] : void 0)).filter((e => void 0 !== e))); r && (t[n] = r) })), t } const b = ["accelerometer", "accessibility", "accessibility-events", "ambient-light-sensor", "background-fetch", "background-sync", "bluetooth", "camera", "clipboard-read", "clipboard-write", "device-info", "display-capture", "gyroscope", "geolocation", "local-fonts", "magnetometer", "microphone", "midi", "nfc", "notifications", "payment-handler", "persistent-storage", "push", "speaker", "storage-access", "top-level-storage-access", "window-management", "query"]; function M() { let e = []; const n = { "prefers-contrast": ["high", "more", "low", "less", "forced", "no-preference"], "any-hover": ["hover", "none"], "any-pointer": ["none", "coarse", "fine"], pointer: ["none", "coarse", "fine"], hover: ["hover", "none"], update: ["fast", "slow"], "inverted-colors": ["inverted", "none"], "prefers-reduced-motion": ["reduce", "no-preference"], "prefers-reduced-transparency": ["reduce", "no-preference"], scripting: ["none", "initial-only", "enabled"], "forced-colors": ["active", "none"] }; return Object.keys(n).forEach((t => { n[t].forEach((n => { matchMedia(`(${t}: ${n})`).matches && e.push(`${t}: ${n}`) })) })), e } const P = "SamsungBrowser" !== r().name ? 1 : 3; let E, A = null; const C = { audio: async function () { const e = r(); return ["SamsungBrowser", "Safari"].includes(e.name) ? null : async function () { return new Promise(((e, n) => { try { const n = 44100, t = 5e3, r = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, t, n), o = r.createBufferSource(), a = r.createOscillator(); a.frequency.value = 1e3; const s = r.createDynamicsCompressor(); let c; s.threshold.value = -50, s.knee.value = 40, s.ratio.value = 12, s.attack.value = 0, s.release.value = .2, a.connect(s), s.connect(r.destination), a.start(), r.oncomplete = n => { c = n.renderedBuffer.getChannelData(0), e({ sampleHash: i(c), maxChannels: r.destination.maxChannelCount, channelCountMode: o.channelCountMode }) }, r.startRendering() } catch (e) { console.error("Error creating audio fingerprint:", e), n(e) } })) }() }, canvas: async function () { const e = r(), n = e.name.toLowerCase(), t = e.version.split(".")[0] || "0", o = parseInt(t, 10); return "firefox" === n || "safari" === n && o >= 17 ? null : (document.createElement("canvas"), new Promise((e => { const n = Array.from({ length: 3 }, (() => function () { const e = document.createElement("canvas"), n = e.getContext("2d"); if (!n) return new ImageData(1, 1); e.width = m, e.height = 20; const t = n.createLinearGradient(0, 0, e.width, e.height); t.addColorStop(0, "red"), t.addColorStop(1 / 6, "orange"), t.addColorStop(2 / 6, "yellow"), t.addColorStop(.5, "green"), t.addColorStop(4 / 6, "blue"), t.addColorStop(5 / 6, "indigo"), t.addColorStop(1, "violet"), n.fillStyle = t, n.fillRect(0, 0, e.width, e.height); const r = "Random Text WMwmil10Oo"; n.font = "23.123px Arial", n.fillStyle = "black", n.fillText(r, -5, 15), n.fillStyle = "rgba(0, 0, 255, 0.5)", n.fillText(r, -3.3, 17.7), n.beginPath(), n.moveTo(0, 0), n.lineTo(2 * e.width / 7, e.height), n.strokeStyle = "white", n.lineWidth = 2, n.stroke(); const o = n.getImageData(0, 0, e.width, e.height); return o }())); e({ commonPixelsHash: d(a(n, m, 20).data.toString()).toString() }) }))) }, fonts: async function (e) { const n = r(); return ["Firefox"].includes(n.name) ? null : new Promise(((e, n) => { try { !async function (e) { for (var n; !document.body;)await h(50); const t = document.createElement("iframe"); t.setAttribute("frameBorder", "0"); const r = t.style; r.setProperty("position", "fixed"), r.setProperty("display", "block", "important"), r.setProperty("visibility", "visible"), r.setProperty("border", "0"), r.setProperty("opacity", "0"), t.src = "about:blank", document.body.appendChild(t); const o = t.contentDocument || (null === (n = t.contentWindow) || void 0 === n ? void 0 : n.document); if (!o) throw new Error("Iframe document is not accessible"); e({ iframe: o }), setTimeout((() => { document.body.removeChild(t) }), 0) }((async ({ iframe: n }) => { const t = n.createElement("canvas").getContext("2d"), r = g.map((e => p(t, e))); let o = {}; f.forEach((e => { const n = p(t, e); r.includes(n) || (o[e] = n) })), e(o) })) } catch (e) { n({ error: "unsupported" }) } })) }, hardware: function () { return new Promise(((e, n) => { const t = void 0 !== navigator.deviceMemory ? navigator.deviceMemory : 0, r = window.performance && window.performance.memory ? window.performance.memory : 0; e({ videocard: v(), architecture: w(), deviceMemory: t.toString() || "undefined", jsHeapSizeLimit: r.jsHeapSizeLimit || 0 }) })) }, locales: function () { return new Promise((e => { e({ languages: navigator.language, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone }) })) }, math: function () { return new Promise((e => { e({ acos: Math.acos(.5), asin: y(Math.asin, -1, 1, 97), cos: y(Math.cos, 0, Math.PI, 97), largeCos: Math.cos(1e20), largeSin: Math.sin(1e20), largeTan: Math.tan(1e20), sin: y(Math.sin, -Math.PI, Math.PI, 97), tan: y(Math.tan, 0, 2 * Math.PI, 97) }) })) }, permissions: async function (e) { let n = (null == e ? void 0 : e.permissions_to_check) || b; "safari" === r().name.toLowerCase() && (n = n.filter((e => !["camera", "geolocation", "microphone"].includes(e)))); const t = Array.from({ length: 3 }, (() => async function (e) { const n = {}; for (const t of e) try { const e = await navigator.permissions.query({ name: t }); n[t] = e.state.toString() } catch (e) { } return n }(n))); return Promise.all(t).then((e => S(e, n))) }, plugins: function () { const e = []; if (navigator.plugins) for (let n = 0; n < navigator.plugins.length; n++) { const t = navigator.plugins[n]; e.push([t.name, t.filename, t.description].join("|")) } return new Promise((n => { n({ plugins: e }) })) }, screen: function () { return new Promise((e => { const n = { is_touchscreen: navigator.maxTouchPoints > 0, maxTouchPoints: navigator.maxTouchPoints, colorDepth: screen.colorDepth, mediaMatches: M() }; o() && navigator.maxTouchPoints > 0 && (n.resolution = function () { const e = window.screen.width, n = window.screen.height, t = Math.max(e, n).toString(), r = Math.min(e, n).toString(); return `${t}x${r}` }()), e(n) })) }, system: function () { return new Promise((e => { const n = r(), t = { platform: window.navigator.platform, productSub: navigator.productSub, product: navigator.product, useragent: navigator.userAgent, hardwareConcurrency: navigator.hardwareConcurrency, browser: { name: n.name, version: n.version }, mobile: o() }; "safari" !== n.name.toLowerCase() && (t.applePayVersion = function () { if ("https:" === window.location.protocol && "function" == typeof window.ApplePaySession) try { const e = window.ApplePaySession.supportsVersion; for (let n = 15; n > 0; n--)if (e(n)) return n } catch (e) { return 0 } return 0 }(), t.cookieEnabled = window.navigator.cookieEnabled), e(t) })) }, webgl: async function () { "undefined" != typeof document && (E = document.createElement("canvas"), E.width = 200, E.height = 100, A = E.getContext("webgl")); try { if (!A) throw new Error("WebGL not supported"); const e = Array.from({ length: P }, (() => function () { try { if (!A) throw new Error("WebGL not supported"); const e = "\n          attribute vec2 position;\n          void main() {\n              gl_Position = vec4(position, 0.0, 1.0);\n          }\n      ", n = "\n          precision mediump float;\n          void main() {\n              gl_FragColor = vec4(0.812, 0.195, 0.553, 0.921); // Set line color\n          }\n      ", t = A.createShader(A.VERTEX_SHADER), r = A.createShader(A.FRAGMENT_SHADER); if (!t || !r) throw new Error("Failed to create shaders"); if (A.shaderSource(t, e), A.shaderSource(r, n), A.compileShader(t), !A.getShaderParameter(t, A.COMPILE_STATUS)) throw new Error("Vertex shader compilation failed: " + A.getShaderInfoLog(t)); if (A.compileShader(r), !A.getShaderParameter(r, A.COMPILE_STATUS)) throw new Error("Fragment shader compilation failed: " + A.getShaderInfoLog(r)); const o = A.createProgram(); if (!o) throw new Error("Failed to create shader program"); if (A.attachShader(o, t), A.attachShader(o, r), A.linkProgram(o), !A.getProgramParameter(o, A.LINK_STATUS)) throw new Error("Shader program linking failed: " + A.getProgramInfoLog(o)); A.useProgram(o); const i = 137, a = new Float32Array(4 * i), s = 2 * Math.PI / i; for (let e = 0; e < i; e++) { const n = e * s; a[4 * e] = 0, a[4 * e + 1] = 0, a[4 * e + 2] = Math.cos(n) * (E.width / 2), a[4 * e + 3] = Math.sin(n) * (E.height / 2) } const c = A.createBuffer(); A.bindBuffer(A.ARRAY_BUFFER, c), A.bufferData(A.ARRAY_BUFFER, a, A.STATIC_DRAW); const u = A.getAttribLocation(o, "position"); A.enableVertexAttribArray(u), A.vertexAttribPointer(u, 2, A.FLOAT, !1, 0, 0), A.viewport(0, 0, E.width, E.height), A.clearColor(0, 0, 0, 1), A.clear(A.COLOR_BUFFER_BIT), A.drawArrays(A.LINES, 0, 2 * i); const l = new Uint8ClampedArray(E.width * E.height * 4); A.readPixels(0, 0, E.width, E.height, A.RGBA, A.UNSIGNED_BYTE, l); return new ImageData(l, E.width, E.height) } catch (e) { return new ImageData(1, 1) } finally { A && (A.bindBuffer(A.ARRAY_BUFFER, null), A.useProgram(null), A.viewport(0, 0, A.drawingBufferWidth, A.drawingBufferHeight), A.clearColor(0, 0, 0, 0)) } }())); return { commonPixelsHash: d(a(e, E.width, E.height).data.toString()).toString() } } catch (e) { return { webgl: "unsupported" } } } }, k = {}, x = { timeout: "true" }, T = (e, n, t) => { k[e] = n }; var O = "1.0.0"; function _(e, n, t = "") { const r = {}, o = (null == n ? void 0 : n.exclude) || [], i = (null == n ? void 0 : n.include) || []; for (const [a, s] of Object.entries(e)) { const e = t + a + "."; if ("object" != typeof s || Array.isArray(s)) { const n = o.some((n => e.startsWith(n))), t = i.some((n => e.startsWith(n))); n && !t || (r[a] = s) } else { const t = _(s, n, e); Object.keys(t).length > 0 && (r[a] = t) } } return r } function R() { return O } let I = null, L = null; async function B(e) { const t = { ...n, ...e }, r = { ...C, ...k }, { elapsed: o, resolvedComponents: i } = await D(r, t), a = t.api_key ? ((e, n) => { if (e.cache_api_call && L) return Promise.resolve(L); if (I) return I; const t = fetch("https://api.thumbmarkjs.com/thumbmark", { method: "POST", headers: { "x-api-key": e.api_key, Authorization: "custom-authorized" }, body: JSON.stringify({ components: n, clientHash: d(JSON.stringify(n)) }) }).then((e => { if (!e.ok) throw new Error(`HTTP error! status: ${e.status}`); return e.json() })).then((e => (L = e, I = null, e))).catch((e => (console.error("Error fetching pro data", e), I = null, null))), r = e.timeout || 5e3, o = new Promise((e => { setTimeout((() => { e({ thumbmark: d(JSON.stringify(n)), info: { timed_out: !0 }, version: O }) }), r) })); return I = Promise.race([t, o]), I })(t, i) : null, s = a ? await a : null, c = t.performance ? { elapsed: o } : {}; if (s) { return { components: i, info: s.info || {}, version: R(), thumbmark: s.thumbmark || "undefined", ...c } } return { thumbmark: d(JSON.stringify(i)), components: i, info: { uniqueness: "api only" }, version: R(), ...c } } async function D(e, t) { const r = { ...n, ...t }, o = Object.entries(e).filter((([e]) => { var n; return !(null === (n = null == r ? void 0 : r.exclude) || void 0 === n ? void 0 : n.includes(e)) })).filter((([e]) => { var n, t, o, i; return (null === (n = null == r ? void 0 : r.include) || void 0 === n ? void 0 : n.some((e => e.includes(".")))) ? null === (t = null == r ? void 0 : r.include) || void 0 === t ? void 0 : t.some((n => n.startsWith(e))) : 0 === (null === (o = null == r ? void 0 : r.include) || void 0 === o ? void 0 : o.length) || (null === (i = null == r ? void 0 : r.include) || void 0 === i ? void 0 : i.includes(e)) })), i = o.map((([e]) => e)), a = o.map((([e, n]) => n(t))), s = await function (e, n, t) { return Promise.all(e.map((e => { const r = performance.now(); return Promise.race([e.then((e => ({ value: e, elapsed: performance.now() - r }))), (o = n, i = t, new Promise((e => { setTimeout((() => e(i)), o) }))).then((e => ({ value: e, elapsed: performance.now() - r })))]); var o, i }))) }(a, (null == r ? void 0 : r.timeout) || 5e3, x), c = {}, u = {}; s.forEach(((e, n) => { var t; null != e.value && (u[i[n]] = e.value, c[i[n]] = null !== (t = e.elapsed) && void 0 !== t ? t : 0) })); const l = _(u, r, ""); return { elapsed: c, resolvedComponents: l } } e.Thumbmark = class { constructor(e) { this.options = { ...n, ...e } } async get(e) { return B({ ...this.options, ...e }) } getVersion() { return R() } includeComponent(e, n) { T(e, n) } }, e.getFingerprint = async function (e) { try { const n = await B(t); return e ? { hash: n.thumbmark.toString(), data: n.components } : n.thumbmark.toString() } catch (e) { throw e } }, e.getFingerprintData = async function () { return (await B(t)).components }, e.getFingerprintPerformance = async function () { try { const { elapsed: e, resolvedComponents: n } = await D(C, t); return { ...n, elapsed: e } } catch (e) { throw e } }, e.getThumbmark = B, e.getVersion = R, e.includeComponent = T, e.setOption = function (e, n) { if (!["include", "exclude", "permissions_to_check", "retries", "timeout", "logging", "api_key", "cache_api_call"].includes(e)) throw new Error("Unknown option " + e); if (["include", "exclude", "permissions_to_check"].includes(e) && (!Array.isArray(n) || !n.every((e => "string" == typeof e)))) throw new Error("The value of the include, exclude and permissions_to_check must be an array of strings"); if (["retries", "timeout"].includes(e) && "number" != typeof n) throw new Error("The value of retries must be a number"); t[e] = n } }));
//# sourceMappingURL=thumbmark.umd.js.map